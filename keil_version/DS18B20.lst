C51 COMPILER V9.01   DS18B20                                                               12/05/2023 20:14:37 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN DS18B20.obj
COMPILER INVOKED BY: D:\Program Files\Keil\C51\BIN\C51.EXE src\utils\DS18B20.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PR
                    -INT(.\DS18B20.lst) OBJECT(DS18B20.obj)

line level    source

   1          #include "DS18B20.h"
   2          #include "DELAY.h"
   3          
   4          sbit DSPORT = P1^5;
   5          
   6          // 初始化DS18B20
   7          // 返回值：1成功，0失败
   8          unsigned char initializeDS18B20(void) {
   9   1              int i=0;
  10   1              
  11   1              DSPORT = 0;     //将总线拉低480us~960us
  12   1              delayTenMicroseconds(64);       //延时642us
  13   1              
  14   1              DSPORT = 1;     //然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线拉低
  15   1              
  16   1              while(DSPORT) { //等待DS18B20拉低总线
  17   2                      i ++;
  18   2                      delayOneMillisecond(1);
  19   2                      if(i > 5) return 0;     //等待>5MS, 则初始化失败
  20   2              }
  21   1              
  22   1              return 1;       //初始化成功
  23   1      }
  24          
  25          // 向DS18B20写入一个字节
  26          void writeByteToDS18B20(unsigned char dat) {
  27   1              unsigned int i, j;
  28   1      
  29   1              for(j = 0;j < 8;j ++) {
  30   2                      DSPORT = 0;     //每写入一位数据之前先把总线拉低1us
  31   2                      i ++;
  32   2                      DSPORT = dat & 0x01;    //然后写入一个数据，从最低位开始
  33   2                      
  34   2                      i = 6;
  35   2                      while(i --);    //延时68us，持续时间最少60us
  36   2                      
  37   2                      DSPORT = 1;     //然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
  38   2                      dat >>= 1;
  39   2              }
  40   1      }
  41          
  42          // 读取一个字节的数据
  43          unsigned char readByteFromDS18B20(void) {
  44   1              unsigned char byte=0, bi=0;
  45   1              unsigned int i, j;      
  46   1              
  47   1              for(j = 8;j > 0;j --) {
  48   2                      DSPORT = 0;     //先将总线拉低1us
  49   2                      i ++;
  50   2                      DSPORT = 1;     //然后释放总线
  51   2                      i ++;
  52   2                      i ++;   //延时6us等待数据稳定
  53   2                      bi = DSPORT;    //读取数据，从最低位开始读取
  54   2                      byte = (byte >> 1) | (bi << 7); // 将byte左移一位，然后与上右移7位后的bi，注意移动之后移掉那位补0
C51 COMPILER V9.01   DS18B20                                                               12/05/2023 20:14:37 PAGE 2   

  55   2                      i = 4;  //读取完之后等待48us再接着读取下一个数
  56   2                      while(i --);
  57   2              }                       
  58   1              
  59   1              return byte;
  60   1      }
  61          
  62          //让DS18B20开始转换温度
  63          void changeTemperatureCommandOfDS18B20(void) {
  64   1              initializeDS18B20();
  65   1              delayOneMillisecond(1);
  66   1              writeByteToDS18B20(0xcc);       //跳过ROM操作命令                
  67   1              writeByteToDS18B20(0x44);       //温度转换命令
  68   1      }
  69          
  70          //发送读取温度命令
  71          void readTemperatureCommandOfDS18B20(void)
  72          {       
  73   1              initializeDS18B20();
  74   1              delayOneMillisecond(1);
  75   1              writeByteToDS18B20(0xCC);       //跳过ROM操作命令
  76   1              writeByteToDS18B20(0xBE);       //发送读取温度命令
  77   1      }
  78          
  79          // 读取温度
  80          // 返回值为温度的原始数值(int)，需要装换
  81          int readTemperatureOfDS18B20(void) {
  82   1              int temp = 0;
  83   1              unsigned char tmh, tml;
  84   1              
  85   1              changeTemperatureCommandOfDS18B20();    //先写入转换命令
  86   1              readTemperatureCommandOfDS18B20();      //然后等待转换完后发送读取温度命令
  87   1              tml = readByteFromDS18B20();    //读取温度值共16位，先读低字节
  88   1              tmh = readByteFromDS18B20();    //再读高字节
  89   1              temp = tmh;
  90   1              temp <<= 8;
  91   1              temp |= tml;
  92   1              
  93   1              return temp;
  94   1      }
  95          
  96          void getTemperatureOfDS18B20(unsigned char * buf, float * temperature) {
  97   1              int temp=0;
  98   1          float tp=0;
  99   1          temp = readTemperatureOfDS18B20();
 100   1          if (temp < 0) {    // 当温度值为负数
 101   2                      buf[0] = '-';    //   -
 102   2                      // 读取的温度是实际温度的补码，所以减1，再取反求出原码
 103   2                      temp = temp - 1;
 104   2                      temp = ~temp;
 105   2                      tp = temp;
 106   2                      temp = tp * 0.0625 * 100 + 0.5;
 107   2              // 留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 108   2                      // 后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 109   2                      // 算加上0.5，还是在小数点后面。
 110   2              } else {                        
 111   2                      tp = temp;  //因为数据处理有小数点所以将温度赋给一个浮点型变量
 112   2                      // 如果温度是正的，那么正数的原码就是补码它本身
 113   2                      temp = tp * 0.0625 * 100 + 0.5;
 114   2                      // 留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 115   2                      // 后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 116   2                      // 算加上0.5，还是在小数点后面。
C51 COMPILER V9.01   DS18B20                                                               12/05/2023 20:14:37 PAGE 3   

 117   2                      buf[0] = (temp / 10000) + '0';
 118   2              }
 119   1              buf[1] = (temp % 10000 / 1000) + '0';
 120   1              buf[2] = (temp % 1000 / 100) + '0';
 121   1              buf[3] = '.';
 122   1              buf[4] = (temp % 100 / 10) + '0';
 123   1              buf[5] = 0xDF;
 124   1              buf[6] = 'C';
 125   1      
 126   1              // 文字转数字
 127   1              if (buf[0] == '-') {
 128   2                      tp = (float)(-1 * ((int)(buf[1] - '0') * 10 + (int)(buf[2] - '0') + (int)(buf[4] - '0') * 0.1));
 129   2              } else {
 130   2                      tp = (float)((int)(buf[0] - '0') * 100 + (int)(buf[1] - '0') * 10 + (int)(buf[2] - '0') + (int)(buf[4] -
             - '0') * 0.1);
 131   2              }
 132   1              *temperature = tp;
 133   1              
 134   1              // 如果第一位数字是0，则将第一位数字替换为空格
 135   1              if (buf[0] == '0') buf[0] = ' ';
 136   1              // 如果第二位数字是0，且第一位数字是空格或负号，则将第二位数字替换为第一位数字
 137   1              if (buf[1] == '0' && (buf[0] == ' '||buf[0] == '-')) {
 138   2                      buf[1] = buf[0];
 139   2                      buf[0] = ' ';
 140   2              }
 141   1      
 142   1      }
 143          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    885    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
