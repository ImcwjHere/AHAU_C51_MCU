C51 COMPILER V9.01   DS18B20                                                               12/06/2023 12:06:33 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN .\DS18B20.obj
COMPILER INVOKED BY: D:\Program Files\Keil\C51\BIN\C51.EXE ..\eide\src\utils\DS18B20.c BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\DS18B20.lst) OBJECT(.\DS18B20.obj)

line level    source

   1          #include "DS18B20.h"
   2          
   3          // 初始化DS18B20
   4          // 返回值：1成功，0失败
   5          unsigned char initializeDS18B20(void) {
   6   1              int i=0;
   7   1              
   8   1              DSPORT = 0;     //将总线拉低480us~960us
   9   1              delayTenMicroseconds(64);       //延时642us
  10   1              
  11   1              DSPORT = 1;     //然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线拉低
  12   1              
  13   1              while(DSPORT) { //等待DS18B20拉低总线
  14   2                      i ++;
  15   2                      delayOneMillisecond(1);
  16   2                      if(i > 5) return 0;     //等待>5MS, 则初始化失败
  17   2              }
  18   1              
  19   1              return 1;       //初始化成功
  20   1      }
  21          
  22          // 向DS18B20写入一个字节
  23          void writeByteToDS18B20(unsigned char dat) {
  24   1              unsigned int i, j;
  25   1      
  26   1              for(j = 0;j < 8;j ++) {
  27   2                      DSPORT = 0;     //每写入一位数据之前先把总线拉低1us
  28   2                      i ++;
  29   2                      DSPORT = dat & 0x01;    //然后写入一个数据，从最低位开始
  30   2                      
  31   2                      i = 6;
  32   2                      while(i --);    //延时68us，持续时间最少60us
  33   2                      
  34   2                      DSPORT = 1;     //然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
  35   2                      dat >>= 1;
  36   2              }
  37   1      }
  38          
  39          // 读取一个字节的数据
  40          unsigned char readByteFromDS18B20(void) {
  41   1              unsigned char byte=0, bi=0;
  42   1              unsigned int i, j;      
  43   1              
  44   1              for(j = 8;j > 0;j --) {
  45   2                      DSPORT = 0;     //先将总线拉低1us
  46   2                      i ++;
  47   2                      DSPORT = 1;     //然后释放总线
  48   2                      i ++;
  49   2                      i ++;   //延时6us等待数据稳定
  50   2                      bi = DSPORT;    //读取数据，从最低位开始读取
  51   2                      byte = (byte >> 1) | (bi << 7); // 将byte左移一位，然后与上右移7位后的bi，注意移动之后移掉那位补0
  52   2                      i = 4;  //读取完之后等待48us再接着读取下一个数
  53   2                      while(i --);
  54   2              }                       
C51 COMPILER V9.01   DS18B20                                                               12/06/2023 12:06:33 PAGE 2   

  55   1              
  56   1              return byte;
  57   1      }
  58          
  59          //让DS18B20开始转换温度
  60          void changeTemperatureCommandOfDS18B20(void) {
  61   1              initializeDS18B20();
  62   1              delayOneMillisecond(1);
  63   1              writeByteToDS18B20(0xcc);       //跳过ROM操作命令                
  64   1              writeByteToDS18B20(0x44);       //温度转换命令
  65   1      }
  66          
  67          //发送读取温度命令
  68          void readTemperatureCommandOfDS18B20(void)
  69          {       
  70   1              initializeDS18B20();
  71   1              delayOneMillisecond(1);
  72   1              writeByteToDS18B20(0xCC);       //跳过ROM操作命令
  73   1              writeByteToDS18B20(0xBE);       //发送读取温度命令
  74   1      }
  75          
  76          // 读取温度
  77          // 返回值为温度的原始数值(int)，需要装换
  78          int readTemperatureOfDS18B20(void) {
  79   1              int temp = 0;
  80   1              unsigned char tmh, tml;
  81   1              
  82   1              changeTemperatureCommandOfDS18B20();    //先写入转换命令
  83   1              readTemperatureCommandOfDS18B20();      //然后等待转换完后发送读取温度命令
  84   1              tml = readByteFromDS18B20();    //读取温度值共16位，先读低字节
  85   1              tmh = readByteFromDS18B20();    //再读高字节
  86   1              temp = tmh;
  87   1              temp <<= 8;
  88   1              temp |= tml;
  89   1              
  90   1              return temp;
  91   1      }
  92          
  93          void getTemperatureOfDS18B20(unsigned char * buf, float * temperature) {
  94   1              int temp=0;
  95   1          float tp=0;
  96   1          temp = readTemperatureOfDS18B20();
  97   1          if (temp < 0) {    // 当温度值为负数
  98   2                      buf[0] = '-';    //   -
  99   2                      // 读取的温度是实际温度的补码，所以减1，再取反求出原码
 100   2                      temp = temp - 1;
 101   2                      temp = ~temp;
 102   2                      tp = temp;
 103   2                      temp = tp * 0.0625 * 100 + 0.5;
 104   2              // 留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 105   2                      // 后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 106   2                      // 算加上0.5，还是在小数点后面。
 107   2              } else {                        
 108   2                      tp = temp;  //因为数据处理有小数点所以将温度赋给一个浮点型变量
 109   2                      // 如果温度是正的，那么正数的原码就是补码它本身
 110   2                      temp = tp * 0.0625 * 100 + 0.5;
 111   2                      // 留两个小数点就*100，+0.5是四舍五入，因为C语言浮点数转换为整型的时候把小数点
 112   2                      // 后面的数自动去掉，不管是否大于0.5，而+0.5之后大于0.5的就是进1了，小于0.5的就
 113   2                      // 算加上0.5，还是在小数点后面。
 114   2                      buf[0] = (temp / 10000) + '0';
 115   2              }
 116   1              buf[1] = (temp % 10000 / 1000) + '0';
C51 COMPILER V9.01   DS18B20                                                               12/06/2023 12:06:33 PAGE 3   

 117   1              buf[2] = (temp % 1000 / 100) + '0';
 118   1              buf[3] = '.';
 119   1              buf[4] = (temp % 100 / 10) + '0';
 120   1              buf[5] = 0xDF;
 121   1              buf[6] = 'C';
 122   1      
 123   1              // 文字转数字
 124   1              if (buf[0] == '-') {
 125   2                      tp = (float)(-1 * ((int)(buf[1] - '0') * 10 + (int)(buf[2] - '0') + (int)(buf[4] - '0') * 0.1));
 126   2              } else {
 127   2                      tp = (float)((int)(buf[0] - '0') * 100 + (int)(buf[1] - '0') * 10 + (int)(buf[2] - '0') + (int)(buf[4] -
             - '0') * 0.1);
 128   2              }
 129   1              *temperature = tp;
 130   1              
 131   1              // 如果第一位数字是0，则将第一位数字替换为空格
 132   1              if (buf[0] == '0') buf[0] = ' ';
 133   1              // 如果第二位数字是0，且第一位数字是空格或负号，则将第二位数字替换为第一位数字
 134   1              if (buf[1] == '0' && (buf[0] == ' '||buf[0] == '-')) {
 135   2                      buf[1] = buf[0];
 136   2                      buf[0] = ' ';
 137   2              }
 138   1      
 139   1      }
 140          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    885    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
